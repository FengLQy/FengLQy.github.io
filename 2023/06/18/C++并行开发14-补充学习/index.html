<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="The Redefine Team">
    <link rel="canonical" href="http://example.com/2023/06/18/C++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%9114-%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            C++并行开发14-补充学习 |
        
        Theme Redefine
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.0.0","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Theme Redefine
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:3rem; font-weight: bold; margin: 10px 0;">C++并行开发14-补充学习</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">The Redefine Team</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-06-18 22:40:09</span>
        <span class="mobile">2023-06-18 22:40</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要是C++异步和同步线程进行总结</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>线程同步主要是为了解决对共享数据的竞争访问问题，所以线程同步主要是对共享数据的访问同步化（按照既定的先后次序，一个访问需要阻塞等待前一个访问完成后才能开始）。这篇文章谈到的异步编程主要是针对任务或线程的执行顺序，也即一个任务不需要阻塞等待上一个任务执行完成后再开始执行，程序的执行顺序与任务的排列顺序是不一致的。下面从任务执行顺序的角度解释下同步与异步的区别：<br>同步：就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。<br>异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。<br>多线程是实现异步编程的一种方式。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int accumulate(std::vector&lt;int&gt;::iterator first,</span><br><span class="line">                std::vector&lt;int&gt;::iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; 1000; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;accumulate ------------------------------- &quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = std::accumulate(first, last, 0);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 演示用 async 在线程间传递结果。</span><br><span class="line">    std::vector&lt;int&gt; numbers = &#123; 1, 2, 3, 4, 5, 6 &#125;;</span><br><span class="line">    auto accumulate_future = std::async(std::launch::async, accumulate, numbers.begin(), numbers.end());        //auto可以自动推断变量的类型</span><br><span class="line"></span><br><span class="line">    //多线程是实现异步编程的一种方式</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 1000; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;main ***********************&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;result=&quot; &lt;&lt; accumulate_future.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分的输出中accumulate  和main 是并存的</p>
<h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h2><p>C++11中的std::async是个模板函数。std::async异步调用函数，在某个时候以Args作为参数(可变长参数)调用Fn，无需等待Fn执行完成就可返回，返回结果是个std::future对象。Fn返回的值可通过std::future对象的get成员函数获取。一旦完成Fn的执行，共享状态将包含Fn返回的值并ready。<br>std::async有两个版本：<br>1.无需显示指定启动策略，自动选择，因此启动策略是不确定的，可能是launch::async，也可能是launch::deferred，或者是两者的任意组合，取决于它们的系统和特定库实现。<br>2.允许调用者选择特定的启动策略。 std::async的启动策略类型是个枚举类enum class launch，包括：</p>
<ol>
<li><p>launch::async：异步，启动一个新的线程调用Fn，该函数由新线程异步调用，并且将其返回值与共享状态的访问点同步。</p>
</li>
<li><p>launch::deferred：延迟，在访问共享状态时该函数才被调用。对Fn的调用将推迟到返回的std::future的共享状态被访问时(使用std::future的wait或get函数)。</p>
</li>
</ol>
<p>参数Fn：可以为函数指针、成员指针、任何类型的可移动构造的函数对象(即类定义了operator()的对象)。Fn的返回值或异常存储在共享状态中以供异步的std::future对象检索。<br>参数Args：传递给Fn调用的参数，它们的类型应是可移动构造的。<br>返回值：当Fn执行结束时，共享状态的std::future对象准备就绪。std::future的成员函数get检索的值是Fn返回的值。当启动策略采用launch::async时，即使从不访问其共享状态，返回的std::future也会链接到被创建线程的末尾。在这种情况下，std::future的析构函数与Fn的返回同步。<br>详细用法见下面的测试代码，下面是从其他文章中copy的测试代码，部分作了调整，详细内容介绍可以参考对应的reference：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: your name</span><br><span class="line"> * @Date: 2021-01-25 11:16:44</span><br><span class="line"> * @LastEditTime: 2021-01-29 17:44:42</span><br><span class="line"> * @LastEditors: Please set LastEditors</span><br><span class="line"> * @Description: In User Settings Edit</span><br><span class="line"> * @FilePath: /myCOde/app/future.cpp</span><br><span class="line"> */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;future&gt;   //引入std::future头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int test_async_1()</span><br><span class="line">&#123;</span><br><span class="line">    auto is_prime = [](int x) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Calculating. Please, wait...\n&quot;;</span><br><span class="line">        for (int i = 2; i &lt; x; ++i) if (x%i == 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // call is_prime(313222313) asynchronously:</span><br><span class="line">    std::future&lt;bool&gt; fut = std::async(is_prime, 313222313);  //执行这一句的时候就已经开始调用函数了</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(2000));</span><br><span class="line">    std::cout &lt;&lt; &quot;Checking whether 313222313 is prime.\n&quot;;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    bool ret = fut.get(); // waits for is_prime to return</span><br><span class="line">    if (ret) std::cout &lt;&lt; &quot;It is prime!\n&quot;;</span><br><span class="line">    else std::cout &lt;&lt; &quot;It is not prime.\n&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int test_async_2()</span><br><span class="line">&#123;</span><br><span class="line">    auto print_ten = [](char c, int ms) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(ms));</span><br><span class="line">            std::cout &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;with launch::async:\n&quot;;</span><br><span class="line">    std::future&lt;void&gt; foo = std::async(std::launch::async, print_ten, &#x27;*&#x27;, 100);</span><br><span class="line">    std::future&lt;void&gt; bar = std::async(std::launch::async, print_ten, &#x27;@&#x27;, 200);</span><br><span class="line">    // async &quot;get&quot; (wait for foo and bar to be ready):</span><br><span class="line">    foo.get(); // 注：注释掉此句，也会输出&#x27;*&#x27;</span><br><span class="line">    bar.get();</span><br><span class="line">    std::cout &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(2000));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;with launch::deferred:\n&quot;;</span><br><span class="line">    foo = std::async(std::launch::deferred, print_ten, &#x27;*&#x27;, 100);</span><br><span class="line">    bar = std::async(std::launch::deferred, print_ten, &#x27;@&#x27;, 200);</span><br><span class="line">    // deferred &quot;get&quot; (perform the actual calls):</span><br><span class="line">    //foo.get(); // 注：注释掉此句，则不会输出&#x27;**********&#x27;</span><br><span class="line">    //bar.get();</span><br><span class="line">    std::cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line">struct X &#123;</span><br><span class="line">    void foo(int i, const std::string&amp; str) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    void bar(const std::string&amp; str) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator()(int i) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        return i + 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int test_async_3()</span><br><span class="line">&#123;</span><br><span class="line">    X x;</span><br><span class="line">    // Calls (&amp;x)-&gt;foo(42, &quot;Hello&quot;) with default policy:</span><br><span class="line">    // may print &quot;Hello 42&quot; concurrently or defer execution</span><br><span class="line">    auto a1 = std::async(&amp;X::foo, &amp;x, 42, &quot;Hello&quot;);</span><br><span class="line">    // Calls x.bar(&quot;world!&quot;) with deferred policy</span><br><span class="line">    // prints &quot;world!&quot; when a2.get() or a2.wait() is called</span><br><span class="line">    auto a2 = std::async(std::launch::deferred, &amp;X::bar, x, &quot;world!&quot;);</span><br><span class="line">    // Calls X()(43); with async policy</span><br><span class="line">    // prints &quot;43&quot; concurrently</span><br><span class="line">    auto a3 = std::async(std::launch::async, X(), 43);</span><br><span class="line">    a2.wait();                     // prints &quot;world!&quot;</span><br><span class="line">    std::cout &lt;&lt; a3.get() &lt;&lt; &#x27;\n&#x27;; // prints &quot;53&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125; //</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    test_async_1();</span><br><span class="line">    test_async_2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h2><p>C++11中的std::promise是个模板类。一个std::promise对象可以存储由future对象(可能在另一个线程中)检索的T类型的值或派生自std::exception的异常，并提供一个同步点。<br>在构造std::promise对象时，该对象与新的共享状态(shared<br>state)关联。通过调用std::promise的get_future函数，可以将该共享状态与std::future对象关联。调用之后，两个对象共享相同的共享状态：(1).std::promise对象是异步提供程序(asynchronous<br>provider)，应 在某个时刻为共享状态设置一个值。(2).std::future对象是个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。<br>模板类std::promise成员函数包括：</p>
<ol>
<li><p>构造函数：(1).默认构造函数：通过访问新的空共享状态来初始化对象(The object is initialized with access to a new empty shared state)。(2).带allocator的构造函数。(3).禁用拷贝构造。(4).支持移动构造。</p>
</li>
<li><p>析构函数：(1).放弃(abandon)共享状态并销毁promise对象。(2).如果有其它future对象关联到同一共享状态，则共享状态本身不会被销毁。(3).如果promise对象在共享状态准备就绪前被销毁，则共享状态自动准备就绪并包含一个std::future_error类型的异常。</p>
</li>
<li><p>get_future函数：(1).返回一个与promise对象的共享状态关联的std::future对象。(2).一旦准备就绪，返回的std::future对象就可以访问promise对象在共享状态上设置的值或异常。(3).每个promise共享状态只能被一个std::future对象检索(Only one future object can be retrieved for each promise shared state)。(4).调用此函数后，promise应在某个时候使其共享状态准备就绪(通过设置值或异常)，否则将在销毁时自动准备就绪并包含一个std::future_error类型的异常。</p>
</li>
<li><p>operator&#x3D;：(1).禁用拷贝赋值。(2).支持移动赋值。</p>
</li>
<li><p>set_exception：将异常指针存储进共享状态即设置共享状态的异常指针，准备就绪。</p>
</li>
<li><p>set_exception_at_thread_exit：设置共享状态的异常指针，但并不将该共享状态的标志设置为ready，当线程退出时，该promise对象会自动设置为ready (Stores the exception pointer p in the shared state without making it ready immediately. Instead, it will be made ready automatically at thread exit, once all objects of thread storage duration have been destroyed)。</p>
</li>
<li><p>set_value：(1).将值存储进共享状态即设置共享状态的值，准备就绪。(2).set_value(void)只是简单使共享状态就绪而无须设置任何值。</p>
</li>
<li><p>set_value_at_thread_exit：设置共享状态的值，但并不将该共享状态的标志设置为ready，当线程退出时，该promise对象会自动设置为ready(Stores val as the value in the shared state without making it ready immediately. Instead, it will be made ready automatically at thread exit, once all objects of thread storage duration have been destroyed)。</p>
</li>
<li><p>swap&#x2F;非成员模板函数swap：交换共享状态。</p>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: your name</span><br><span class="line"> * @Date: 2021-01-25 11:16:44</span><br><span class="line"> * @LastEditTime: 2021-01-29 20:18:12</span><br><span class="line"> * @LastEditors: Please set LastEditors</span><br><span class="line"> * @Description: In User Settings Edit</span><br><span class="line"> * @FilePath: /myCOde/app/future.cpp</span><br><span class="line"> */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;future&gt;   //引入std::future头文件</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test_promise_1()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::promise&lt;int&gt; foo; // create promise</span><br><span class="line">        std::promise&lt;int&gt; bar = std::promise&lt;int&gt;(std::allocator_arg, std::allocator&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">        std::future&lt;int&gt; fut = bar.get_future(); // engagement with future</span><br><span class="line">        auto print_int = [&amp;fut]() &#123; int x = fut.get(); fprintf(stdout, &quot;value: %d\n&quot;, x); &#125;;</span><br><span class="line">        std::thread th1(print_int); // send future to new thread</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class="line">        cout &lt;&lt; &quot;set value ... &quot; &lt;&lt; endl;</span><br><span class="line">        bar.set_value(10); </span><br><span class="line">        cout &lt;&lt; &quot;set value over &quot; &lt;&lt; endl;</span><br><span class="line">        th1.join();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::promise&lt;int&gt; prom;</span><br><span class="line">        std::future&lt;int&gt; fut = prom.get_future();</span><br><span class="line"></span><br><span class="line">        auto get_int = [&amp;prom]() &#123;</span><br><span class="line">            int x;</span><br><span class="line">            std::cout &lt;&lt; &quot;Please, enter an integer value: &quot;;</span><br><span class="line">            std::cin.exceptions(std::ios::failbit); // throw on failbit</span><br><span class="line">            try &#123;</span><br><span class="line">                std::cin &gt;&gt; x; // sets failbit if input is not int</span><br><span class="line">                prom.set_value(x);</span><br><span class="line">            &#125; catch (std::exception&amp;) &#123;</span><br><span class="line">                prom.set_exception(std::current_exception());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        auto print_int = [&amp;fut]() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int x = fut.get();</span><br><span class="line">                std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; x &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">            &#125; catch (std::exception&amp; e) &#123;</span><br><span class="line">                std::cout &lt;&lt; &quot;[exception caught: &quot; &lt;&lt; e.what() &lt;&lt; &quot;]\n&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        std::thread th1(print_int);</span><br><span class="line">        std::thread th2(get_int);</span><br><span class="line"></span><br><span class="line">        th1.join();</span><br><span class="line">        th2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里已经传引用</span><br><span class="line">void myAccumulate(std::vector&lt;int&gt;::iterator first, std::vector&lt;int&gt;::iterator last, std::promise&lt;int&gt; accumulate_promise)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = std::accumulate(first, last, 0);</span><br><span class="line">    accumulate_promise.set_value(sum);  // Notify future</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_work(std::promise&lt;void&gt; barrier)</span><br><span class="line">&#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    barrier.set_value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int test_promise_2()&#123;</span><br><span class="line">    std::vector&lt;int&gt; numbers = &#123; 1, 2, 3, 4, 5, 6 &#125;;</span><br><span class="line">    std::promise&lt;int&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;int&gt; accumulate_future = accumulate_promise.get_future();</span><br><span class="line">    std::thread work_thread(myAccumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise));</span><br><span class="line">    std::cout &lt;&lt; &quot;result=&quot; &lt;&lt; accumulate_future.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));  //这里加入延迟的目的是为了可以更加真实的看出当前的运行流程</span><br><span class="line">    cout &lt;&lt; &quot;accumulate_future get &quot; &lt;&lt; endl; </span><br><span class="line">    work_thread.join();  // wait for thread completion</span><br><span class="line"></span><br><span class="line">    // Demonstrate using promise&lt;void&gt; to signal state between threads.</span><br><span class="line">    cout &lt;&lt; &quot;run to this &quot; &lt;&lt; endl;</span><br><span class="line">    std::promise&lt;void&gt; barrier;</span><br><span class="line">    std::future&lt;void&gt; barrier_future = barrier.get_future();</span><br><span class="line">    std::thread new_work_thread(do_work, std::move(barrier));</span><br><span class="line">    barrier_future.wait();</span><br><span class="line">    new_work_thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test_peomise_3()&#123;</span><br><span class="line">    std::promise&lt;int&gt; p;</span><br><span class="line">    std::future&lt;int&gt; f = p.get_future();</span><br><span class="line"></span><br><span class="line">    std::thread([&amp;p] &#123;</span><br><span class="line">        std::this_thread::sleep_for(1s);</span><br><span class="line">        p.set_value_at_thread_exit(9); // gcc 4.9 don&#x27;t support this function</span><br><span class="line">    &#125;).detach();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Waiting...&quot; &lt;&lt; std::flush;</span><br><span class="line">    f.wait();</span><br><span class="line">    std::cout &lt;&lt; &quot;Done!\nResult is: &quot; &lt;&lt; f.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    test_promise_1();</span><br><span class="line">    test_promise_2();</span><br><span class="line">    test_peomise_3();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h2><p>C++11中的std::packaged_task是个模板类。std::packaged_task包装任何可调用目标(函数、lambda表达式、bind表达式、函数对象)以便它可以被异步调用。它的返回值或抛出的异常被存储于能通过std::future对象访问的共享状态中。<br>std::packaged_task类似于std::function，但是会自动将其结果传递给std::future对象。<br>std::packaged_task对象内部包含两个元素：(1).存储的任务(stored<br>task)是一些可调用的对象(例如函数指针、成员或函数对象的指针)( A stored task, which is some callable<br>object (such as a function pointer, pointer to member or function<br>object))。(2).共享状态，它可以存储调用存储的任务(stored task)的结果，并可以通过std::future进行异步访问(A shared<br>state, which is able to store the results of calling the stored task and be<br>accessed asynchronously through a future)。<br>通过调用std::packaged_task的get_future成员将共享状态与std::future对象关联。调用之后，两个对象共享相同的共享状态：(1).std::packaged_task对象是异步提供程序(asynchronous<br>provider)，应通过调用存储的任务(stored<br>task)在某个时刻将共享状态设置为就绪。(2).std::future对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。<br>共享状态的生存期至少要持续到与之关联的最后一个对象释放或销毁为止。 std::packaged_task不会自己启动，你必须调用它(A<br>packaged_task won’t start on it’s own, you have to invoke it)。<br>模板类std::packaged_task成员函数包括：</p>
<ol>
<li><p>构造函数：(1).默认构造函数：无共享状态无存储任务(no shared state and no stored task)情况下初始化对象。(2). initialization constructor：该对象具有共享状态，且其存储的任务由fn初始化。(3). initialization constructor with allocator。(4).禁用拷贝构造。(5).支持移动构造。</p>
</li>
<li><p>析构函数：(1).放弃(abandon)共享状态并销毁packaged_task对象。(2). 如果有其它future对象关联到同一共享状态，则共享状态本身不会被销毁。(3). 如果packaged_task对象在共享状态准备就绪前被销毁，则共享状态自动准备就绪并包含一个std::future_error类型的异常。</p>
</li>
<li><p>get_future函数：(1).返回一个与packaged_task对象的共享状态关联的std::future对象。(2).一旦存储的任务被调用，返回的std::future对象就可以访问packaged_task对象在共享状态上设置的值或异常。(3).每个packaged_task共享状态只能被一个std::future对象检索(Only one future object can be retrieved for each packaged_task shared state)。(4).调用此函数后，packaged_task应在某个时候使其共享状态准备就绪(通过调用其存储的任务)，否则将在销毁后自动准备就绪并包含一个std::future_error类型的异常。</p>
</li>
<li><p>make_ready_at_thread_exit函数：在线程退出时才使共享状态ready而不是在调用完成后就立即ready。</p>
</li>
<li><p>operator&#x3D;：(1).禁用拷贝赋值。(2).支持移动赋值。</p>
</li>
<li><p>operator()：(1).call stored task。(2).如果对存储任务的调用成功完成或抛出异常，则返回的值或捕获的异常存储在共享状态，共享状态准备就绪(解除阻塞当前等待它的所有线程)。</p>
</li>
<li><p>reset函数：(1).在保持相同存储的任务的同时，以新的共享状态重置对象。(2).允许再次调用存储的任务。(3).与对象关联的之前的共享状态被放弃(就像packaged_task被销毁了一样)。(4).在内部，该函数的行为就像是移动赋值了一个新构造的packaged_task一样(Internally, the function behaves as if move-assigned a newly constructed packaged_task (with its stored task as argument))。</p>
</li>
<li><p>swap函数&#x2F;非成员模板函数swap：交换共享状态和存储的任务(stored task)。</p>
</li>
<li><p>valid函数：检查packaged_task对象是否具有共享状态。</p>
</li>
</ol>
<p>packaged_task想要实现异步，必须调用thread，创建一个新的线程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: your name</span><br><span class="line"> * @Date: 2021-01-25 11:16:44</span><br><span class="line"> * @LastEditTime: 2021-01-29 21:09:55</span><br><span class="line"> * @LastEditors: Please set LastEditors</span><br><span class="line"> * @Description: In User Settings Edit</span><br><span class="line"> * @FilePath: /myCOde/app/future.cpp</span><br><span class="line"> */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;future&gt;   //引入std::future头文件</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test_packaged_task_1()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    std::packaged_task&lt;int(int)&gt; foo;</span><br><span class="line">    std::packaged_task&lt;int(int)&gt; bar([](int x)&#123; return x * 2;&#125;);</span><br><span class="line"></span><br><span class="line">    foo = std::move(bar);  //右移</span><br><span class="line">    std::cout &lt;&lt; &quot;vaild: &quot; &lt;&lt; foo.valid() &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;vaild: &quot; &lt;&lt; bar.valid() &lt;&lt; endl;</span><br><span class="line">    std::future&lt;int&gt; ret = foo.get_future();  //get future</span><br><span class="line">    std::thread(std::move(foo), 10).detach();</span><br><span class="line"></span><br><span class="line">    int value =  ret.get();</span><br><span class="line">    std::cout &lt;&lt; &quot;The double of 10 is &quot; &lt;&lt; value &lt;&lt; &quot;.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; // reset/operator()</span><br><span class="line">    std::packaged_task&lt;int(int)&gt; tsk([](int x) &#123; return x * 3; &#125;); // package task</span><br><span class="line"></span><br><span class="line">    std::future&lt;int&gt; fut = tsk.get_future();</span><br><span class="line">    tsk(33);</span><br><span class="line">    std::cout &lt;&lt; &quot;The triple of 33 is &quot; &lt;&lt; fut.get() &lt;&lt; &quot;.\n&quot;;</span><br><span class="line"></span><br><span class="line">    // re-use same task object:</span><br><span class="line">    tsk.reset();</span><br><span class="line">    fut = tsk.get_future();</span><br><span class="line">    std::thread(std::move(tsk), 99).detach();</span><br><span class="line">    std::cout &lt;&lt; &quot;Thre triple of 99 is &quot; &lt;&lt; fut.get() &lt;&lt; &quot;.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    auto countdown = [](int from, int to) &#123;</span><br><span class="line">    for (int i = from; i != to; --i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Lift off!\n&quot;;</span><br><span class="line">    return from - to;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::packaged_task&lt;int(int, int)&gt; tsk(countdown); // set up packaged_task</span><br><span class="line">    std::future&lt;int&gt; ret = tsk.get_future(); // get future</span><br><span class="line"></span><br><span class="line">    std::thread th(std::move(tsk), 5, 0); // spawn thread to count down from 5 to 0</span><br><span class="line"></span><br><span class="line">    int value = ret.get(); // wait for the task to finish and get result</span><br><span class="line">    std::cout &lt;&lt; &quot;The countdown lasted for &quot; &lt;&lt; value &lt;&lt; &quot; seconds.\n&quot;;</span><br><span class="line"></span><br><span class="line">    th.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int test_packaged_task_2()</span><br><span class="line">&#123;</span><br><span class="line">&#123; // lambda</span><br><span class="line">    std::packaged_task&lt;int(int, int)&gt; task([](int a, int b) &#123; return std::pow(a, b);&#125;);</span><br><span class="line">    std::future&lt;int&gt; result = task.get_future();</span><br><span class="line"></span><br><span class="line">    task(2, 9);</span><br><span class="line">    std::cout &lt;&lt; &quot;task_lambda:\t&quot; &lt;&lt; result.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; // bind</span><br><span class="line">    std::packaged_task&lt;int()&gt; task(std::bind([](int x, int y) &#123; return std::pow(x, y); &#125;, 2, 11));</span><br><span class="line">    std::future&lt;int&gt; result = task.get_future();</span><br><span class="line"></span><br><span class="line">    task();</span><br><span class="line">    std::cout &lt;&lt; &quot;task_bind:\t&quot; &lt;&lt; result.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; // thread</span><br><span class="line">    std::packaged_task&lt;int(int, int)&gt; task([](int x, int y) &#123; return std::pow(x, y); &#125;);</span><br><span class="line">    std::future&lt;int&gt; result = task.get_future();</span><br><span class="line"></span><br><span class="line">    std::thread task_td(std::move(task), 2, 10);</span><br><span class="line">    task_td.join();</span><br><span class="line">    std::cout &lt;&lt; &quot;task_thread:\t&quot; &lt;&lt; result.get() &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct DBDataFetcher &#123;</span><br><span class="line">    std::string operator()(std::string token)</span><br><span class="line">    &#123;</span><br><span class="line">        // Do some stuff to fetch the data</span><br><span class="line">        std::string data = &quot;Data From &quot; + token;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//使用仿函数</span><br><span class="line">int test_packaged_task_3()</span><br><span class="line">&#123;</span><br><span class="line">    // Create a packaged_task&lt;&gt; that encapsulated a Function Object</span><br><span class="line">    std::packaged_task&lt;std::string(std::string)&gt; task(std::move(DBDataFetcher()));</span><br><span class="line"></span><br><span class="line">    // Fetch the associated future&lt;&gt; from packaged_task&lt;&gt;</span><br><span class="line">    std::future&lt;std::string&gt; result = task.get_future();</span><br><span class="line"></span><br><span class="line">    // Pass the packaged_task to thread to run asynchronously</span><br><span class="line">    std::thread th(std::move(task), &quot;Arg&quot;);</span><br><span class="line"></span><br><span class="line">    // Join the thread. Its blocking and returns when thread is finished.</span><br><span class="line">    th.join();</span><br><span class="line"></span><br><span class="line">    // Fetch the result of packaged_task&lt;&gt; i.e. value returned by getDataFromDB()</span><br><span class="line">    std::string data = result.get();</span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int test_packaged_task_4()</span><br><span class="line">&#123;</span><br><span class="line">    // sleeps for one second and returns 1</span><br><span class="line">    auto sleep = []() &#123;</span><br><span class="line">    //  // for(int i = 0; i &lt; 1000; i++)&#123;</span><br><span class="line">    //  //  cout &lt;&lt; &quot;packaged task ----------&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    //  // &#125;</span><br><span class="line">        // std::this_thread::sleep_for(std::chrono::seconds(100));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#123; // std::packaged_task</span><br><span class="line">    // &gt;&gt;&gt;&gt;&gt; A packaged_task won&#x27;t start on it&#x27;s own, you have to invoke it</span><br><span class="line">    std::packaged_task&lt;int()&gt; task(sleep);</span><br><span class="line"></span><br><span class="line">    auto f = task.get_future();</span><br><span class="line">    task(); // invoke the function</span><br><span class="line">    for(int i = 0; i &lt; 1000; i++)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;main -----------&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // You have to wait until task returns. Since task calls sleep</span><br><span class="line">    // you will have to wait at least 1 second.</span><br><span class="line">    std::cout &lt;&lt; &quot;You can see this after 1 second\n&quot;;</span><br><span class="line"></span><br><span class="line">    // However, f.get() will be available, since task has already finished.</span><br><span class="line">    std::cout &lt;&lt; f.get() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; // std::async</span><br><span class="line">    // &gt;&gt;&gt;&gt;&gt; On the other hand, std::async with launch::async will try to run the task in a different thread :</span><br><span class="line">    auto f = std::async(std::launch::async, sleep);</span><br><span class="line">    std::cout &lt;&lt; &quot;You can see this immediately!\n&quot;;</span><br><span class="line"></span><br><span class="line">    // However, the value of the future will be available after sleep has finished</span><br><span class="line">    // so f.get() can block up to 1 second.</span><br><span class="line">    std::cout &lt;&lt; f.get() &lt;&lt; &quot;This will be shown after a second!\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // test_packaged_task_1();</span><br><span class="line">    test_packaged_task_4();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43196107/article/details/89679123">异步和同步的区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/lx17746071609/p/11128255.html">C++多线程并发—异步编程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/woliuyunyicai/article/details/45165869">并发和并行，异步与多线程区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/104115489/">C++11中std::future的使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/104133494">std::aysnc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/104124174">std::promise <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/104127352">std::packaged_task <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：C++并行开发14-补充学习</li>
        <li>Post author：The Redefine Team</li>
        <li>Create time：2023-06-18 22:40:09</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/06/18/C++并行开发14-补充学习/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/06/18/C++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%919-async%E3%80%81future%E3%80%81packaged_task%E3%80%81promise/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">C++并行开发9-async、future、packaged_task、promise</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/06/18/%E5%B8%B8%E8%A7%81%E5%88%86%E5%89%B2loss/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">常见分割loss</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">C++并行开发14-补充学习</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-text">异步编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-async"><span class="nav-text">std::async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-promise"><span class="nav-text">std::promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-packaged-task"><span class="nav-text">std::packaged_task</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">The Redefine Team. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.0.0</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/8/17 11:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        

        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
